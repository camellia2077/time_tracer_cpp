# 开发设计模式与工程实践 (Updated)

## 1. 关注点分离：业务、IO 与编排 (Separation of Concerns)

系统的设计核心在于将“做什么（逻辑）”、“怎么存（IO）”与“何时做（编排）”彻底解耦。

### 1.1 业务逻辑模块的纯净化 (Pure Logic Units)

* **设计准则**：具体的业务 Service（如 `ConverterService`）被设计为**纯粹的计算单元**。
* **实现方式**：
* **禁止直接 IO**：业务模块不直接操作文件系统或数据库，而是通过标准输入输出流（如 `std::istream`）或数据对象进行交互。
* **所有权移交**：通过回调函数（如 `std::function<void(DailyLog&&)>`）将生成的数据对象移交给外部，而不关心数据最终是写入磁盘还是存入数据库。



### 1.2 IO 模块的工具化 (Utility IO)

* **设计准则**：所有的文件读写、路径检查和目录管理统一托管在 `io` 命名空间下。

### 1.3 Core 层的编排化与流水线设计 (Orchestration & Pipeline)

* **设计准则**：`core` 模块作为系统的“大脑”，不再只是简单的功能集合，而是**任务流水线 (Pipeline)** 的管理者。
* **实现方式**：
* **Blink 模式 (Ingest)**：将数据校验、转换、持久化整合为原子化的“摄取”操作，确保系统状态从“原始文件”安全迁移至“结构化数据库”。
* **前置依赖检查**：Core 层负责在任务启动前验证环境（如数据库文件是否存在、插件是否就绪），防止业务层处理无效数据。

### 1.4 领域模型与视图模型的分离 (Separation of Domain vs. View Models)

系统严格区分了**核心资产**与**展示形态**，导致了 Ingest 和 Export 流程在架构上的不对称性：

* **核心领域 (Core Domain)**: 
    * **对应流程**: 数据摄取 (Ingest/Import)。
    * **处理逻辑**: 必须由 `Core` 亲自管控。因为 `DailyLog` 代表了用户数据，Core 必须负责其解析、校验和持久化的完整性。
    
* **视图模型 (View Model)**: 
    * **对应流程**: 报表导出 (Export/Query)。
    * **处理逻辑**: 委托给 `Reports` 模块。`DailyReportData` 等结构体仅用于展示，属于“易变”的视图层细节。
    * **隔离策略**: `Core` 不直接触碰报表结构体，仅作为调度者请求 `Reports` 模块生成最终的 String/File。这确保了修改报表格式（View）不会影响核心业务逻辑（Domain）。

### 1.5 幂等性与中间层设计 (Idempotency & Intermediate Layer)

系统采用 `TXT (Source) -> Struct -> JSON (Staging) -> Struct -> DB (Persistence)` 的“回旋镖”式数据流，虽然看似增加了步骤，但实则构建了极高的系统鲁棒性。

* **JSON 作为这一流程的“防腐层”与“检查点”**：
    * **可观测性 (Observability)**：通过将内存中的 `Struct` 落地为 JSON 文件，开发者和用户可以直观地检查解析逻辑是否符合预期，排查诸如“跨天计算错误”或“分类映射偏差”等问题。
    * **互操作性 (Interoperability)**：标准化的 JSON 中间产物使得数据可以轻松被第三方工具（如 Python 分析脚本或 Web 前端）直接消费，而无需耦合底层的 C++ 数据结构或 SQL 模式。

* **全量重放能力 (Replayability)**：
    * 系统的导入逻辑设计为**幂等 (Idempotent)** 的。这意味着用户可以随时修改原始 TXT 文件中的任何一行，然后重新运行导入命令。系统会覆盖数据库中的旧记录，确保数据库状态始终是文本文件的精确投影。



---

## 2. 模型与配置的耦合策略

系统采用“**外周解耦，核心耦合**”的策略，利用 `common` 模块作为全系统的通信语言。

### 2.1 Common 层的中心化

* **设计准则**：将全局通用的数据模型和配置定义提取至 `common` 层。
* **强耦合逻辑**：Core 层与 `common` 模型保持强耦合，因为编排者必须深刻理解数据结构才能完成调度。

---

## 3. 配置分发与环境管控

### 3.1 引用注入 (Configuration Injection)

* **生命周期**：配置对象由 `main` 函数持有，其生命周期贯穿整个程序。
* **注入路径**：使用 `const AppConfig&` 传递，确保下游模块只能读取配置而无法篡改。

### 3.2 运行环境隔离 (Environment Isolation)

* **设计准则**：通过独立的 `EnvironmentManager` 负责工件（EXE/DLL/Plugins）的物理隔离与准备。
* **动态依赖管控**：系统支持 `plugins` 文件夹的动态复制与加载，使得核心逻辑与可选插件在物理层面实现解耦。

---

## 4. 后续开发准则 (Updated)

* **新增业务功能时**：定义在 `Service` 模块中，接受数据流输入，返回结构化模型。
* **新增命令时**：在 Core 层定义新的 `WorkflowHandler`，复用现有的 IO 工具和配置分发机制。
* **防御式编程**：所有涉及数据库或文件导出的模块（如 `Query` 或 `Export`），必须在 Core 层执行前置的存在性检查，严禁在环境不就绪时启动业务逻辑。