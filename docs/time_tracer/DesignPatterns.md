# 开发设计模式与工程实践 (Updated)

## 1. 关注点分离：业务、IO 与编排 (Separation of Concerns)

系统的设计核心在于将“做什么（逻辑）”、“怎么存（IO）”与“何时做（编排）”彻底解耦。

### 1.1 业务逻辑模块的纯净化 (Pure Logic Units)

* **设计准则**：具体的业务 Service（如 `ConverterService`）被设计为**纯粹的计算单元**。
* **实现方式**：
* **禁止直接 IO**：业务模块不直接操作文件系统或数据库，而是通过标准输入输出流（如 `std::istream`）或数据对象进行交互。
* **所有权移交**：通过回调函数（如 `std::function<void(DailyLog&&)>`）将生成的数据对象移交给外部，而不关心数据最终是写入磁盘还是存入数据库。



### 1.2 IO 模块的工具化 (Utility IO)

* **设计准则**：所有的文件读写、路径检查和目录管理统一托管在 `io` 命名空间下。

### 1.3 Core 层的编排化与流水线设计 (Orchestration & Pipeline)

* **设计准则**：`core` 模块作为系统的“大脑”，不再只是简单的功能集合，而是**任务流水线 (Pipeline)** 的管理者。
* **实现方式**：
* **Blink 模式 (Ingest)**：将数据校验、转换、持久化整合为原子化的“摄取”操作，确保系统状态从“原始文件”安全迁移至“结构化数据库”。
* **前置依赖检查**：Core 层负责在任务启动前验证环境（如数据库文件是否存在、插件是否就绪），防止业务层处理无效数据。



---

## 2. 模型与配置的耦合策略

系统采用“**外周解耦，核心耦合**”的策略，利用 `common` 模块作为全系统的通信语言。

### 2.1 Common 层的中心化

* **设计准则**：将全局通用的数据模型和配置定义提取至 `common` 层。
* **强耦合逻辑**：Core 层与 `common` 模型保持强耦合，因为编排者必须深刻理解数据结构才能完成调度。

---

## 3. 配置分发与环境管控

### 3.1 引用注入 (Configuration Injection)

* **生命周期**：配置对象由 `main` 函数持有，其生命周期贯穿整个程序。
* **注入路径**：使用 `const AppConfig&` 传递，确保下游模块只能读取配置而无法篡改。

### 3.2 运行环境隔离 (Environment Isolation)

* **设计准则**：通过独立的 `EnvironmentManager` 负责工件（EXE/DLL/Plugins）的物理隔离与准备。
* **动态依赖管控**：系统支持 `plugins` 文件夹的动态复制与加载，使得核心逻辑与可选插件在物理层面实现解耦。

---

## 4. 后续开发准则 (Updated)

* **新增业务功能时**：定义在 `Service` 模块中，接受数据流输入，返回结构化模型。
* **新增命令时**：在 Core 层定义新的 `WorkflowHandler`，复用现有的 IO 工具和配置分发机制。
* **防御式编程**：所有涉及数据库或文件导出的模块（如 `Query` 或 `Export`），必须在 Core 层执行前置的存在性检查，严禁在环境不就绪时启动业务逻辑。